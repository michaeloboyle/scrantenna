<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrantenna Shorts</title>
    <script src="https://unpkg.com/vis-network@latest/standalone/umd/vis-network.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .shorts-container {
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
        }

        .short {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .short.active {
            opacity: 1;
            transform: translateY(0);
        }

        .short.prev {
            transform: translateY(-100%);
        }

        .short.next {
            transform: translateY(100%);
        }

        .headline {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 2rem;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            animation: slideInUp 1s ease-out;
        }

        .headline.svo {
            font-size: clamp(1.5rem, 6vw, 3rem);
            color: #FFD700;
            font-weight: 700;
        }

        .content {
            font-size: clamp(1rem, 4vw, 1.5rem);
            line-height: 1.4;
            max-width: 80%;
            margin-bottom: 2rem;
            animation: slideInUp 1s ease-out 0.3s both;
        }

        .metadata {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            right: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            opacity: 0.8;
            animation: fadeIn 1s ease-out 0.6s both;
        }

        .source {
            background: rgba(255,255,255,0.2);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .navigation {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 100;
        }

        .nav-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: #FFD700;
            transition: width 0.3s ease;
        }

        .mode-controls {
            position: fixed;
            top: 2rem;
            right: 2rem;
            display: flex;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }

        .mode-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            min-width: 65px;
        }

        .mode-btn.active {
            background: rgba(255,255,255,0.2);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.9);
        }

        .mode-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        .mode-label {
            font-size: 0.75rem;
            line-height: 1;
            letter-spacing: 0.5px;
        }

        .graph-container {
            width: 100%;
            height: calc(100vh - 120px);
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
        }

        .graph-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px 12px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 10;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .graph-title {
            font-size: 1rem;
            font-weight: 600;
            color: white;
            margin: 0;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .graph-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
        }

        .graph-content {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 0 0 12px 12px;
        }

        .engagement-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.9);
            color: black;
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .engagement-indicator.visible {
            opacity: 1;
        }

        .entity-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid rgba(255,255,255,0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 15;
        }

        .entity-info.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .entity-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: white;
            margin-bottom: 0.25rem;
        }

        .entity-type {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .graph-svg {
            max-width: 90%;
            max-height: 100%;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .graph-placeholder {
            color: white;
            text-align: center;
            font-size: 1.2rem;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Background patterns */
        .short:nth-child(1) { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .short:nth-child(2) { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .short:nth-child(3) { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .short:nth-child(4) { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .short:nth-child(5) { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .short {
                padding: 1rem;
            }
            
            .navigation {
                right: 1rem;
            }
            
            .mode-controls {
                top: 1rem;
                right: 1rem;
            }
            
            .mode-btn {
                padding: 0.5rem 0.75rem;
                min-width: 55px;
            }
            
            .mode-icon {
                font-size: 1rem;
            }
            
            .mode-label {
                font-size: 0.7rem;
            }
            
            .metadata {
                bottom: 1rem;
                left: 1rem;
                right: 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .graph-header {
                height: 50px;
                padding: 0 1rem;
            }

            .graph-title {
                font-size: 0.9rem;
            }

            .graph-meta {
                font-size: 0.7rem;
                gap: 0.5rem;
            }

            .graph-content {
                top: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="shorts-container" id="shortsContainer">
        <!-- Shorts will be dynamically loaded here -->
    </div>

    <div class="navigation">
        <button class="nav-btn" onclick="previousShort()">‚Üë</button>
        <button class="nav-btn" onclick="nextShort()">‚Üì</button>
    </div>

    <div class="mode-controls">
        <button class="mode-btn active" onclick="setMode('read')" id="readBtn">
            <span class="mode-icon">üìñ</span>
            <span class="mode-label">Read</span>
        </button>
        <button class="mode-btn" onclick="setMode('brief')" id="briefBtn">
            <span class="mode-icon">üìù</span>
            <span class="mode-label">Brief</span>
        </button>
        <button class="mode-btn" onclick="setMode('explore')" id="exploreBtn">
            <span class="mode-icon">üï∏Ô∏è</span>
            <span class="mode-label">Explore</span>
        </button>
    </div>

    <script>
        let currentShort = 0;
        let shorts = [];
        let currentMode = 'read'; // 'read', 'brief', or 'explore'
        let graphEngaged = false; // Track if user is interacting with graph
        let autoAdvanceTimer = null; // Store timer reference

        // Function to mark graph as engaged and show indicator
        function markGraphEngaged() {
            graphEngaged = true;
            const indicator = document.getElementById(`engagement-${currentShort}`);
            if (indicator) {
                indicator.classList.add('visible');
                // Hide indicator after 3 seconds
                setTimeout(() => {
                    if (indicator) {
                        indicator.classList.remove('visible');
                    }
                }, 3000);
            }
        }

        async function loadNews() {
            try {
                // Load optimized shorts data
                const response = await fetch('shorts_data.json');
                const data = await response.json();
                
                shorts = data.shorts;
                createShorts();
                showShort(0);
                
                console.log(`Loaded ${shorts.length} shorts (${data.total_duration}s total)`);
            } catch (error) {
                console.error('Error loading shorts:', error);
                // Fallback to original news data
                try {
                    const response = await fetch('../data/daily/scranton_news_2025-06-25.json');
                    const data = await response.json();
                    
                    shorts = data.articles.slice(0, 10);
                    createShorts();
                    showShort(0);
                } catch (fallbackError) {
                    console.error('Fallback also failed:', fallbackError);
                    loadDemoData();
                }
            }
        }

        function loadDemoData() {
            shorts = [
                {
                    title: "Sample News Story",
                    title_svo: "Reporter reports story.",
                    description: "This is a sample news description for demonstration purposes.",
                    description_svo: "Article mentions demonstration purposes.",
                    source: "Demo Source",
                    publishedAt: new Date().toISOString(),
                    background_gradient: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)"
                }
            ];
            createShorts();
            showShort(0);
        }

        function createShorts() {
            const container = document.getElementById('shortsContainer');
            container.innerHTML = '';

            shorts.forEach((article, index) => {
                const shortDiv = document.createElement('div');
                shortDiv.className = 'short';
                if (article.background_gradient) {
                    shortDiv.style.background = article.background_gradient;
                }
                if (currentMode === 'explore') {
                    shortDiv.innerHTML = `
                        <div class="graph-container">
                            <div class="graph-header">
                                <div class="graph-title">${article.title || 'Knowledge Graph'}</div>
                                <div class="graph-meta">
                                    <span>${article.source || article.source?.name || 'Unknown'}</span>
                                    <span>${new Date(article.publishedAt).toLocaleDateString()}</span>
                                </div>
                            </div>
                            <div class="engagement-indicator" id="engagement-${index}">
                                üîç Exploring - Auto-advance paused
                            </div>
                            <div class="graph-content">
                                <div id="graph-${index}" class="graph-placeholder">
                                    <p>Loading knowledge graph...</p>
                                </div>
                                <div class="entity-info" id="entity-info-${index}">
                                    <div class="entity-name" id="entity-name-${index}"></div>
                                    <div class="entity-type" id="entity-type-${index}"></div>
                                </div>
                            </div>
                        </div>
                        <div class="progress-bar" style="width: ${((index + 1) / shorts.length) * 100}%"></div>
                    `;
                    
                    // Load graph for this article immediately
                    setTimeout(() => loadGraphForArticle(index, article), 100);
                } else {
                    const isRead = currentMode === 'read';
                    const isBrief = currentMode === 'brief';
                    
                    shortDiv.innerHTML = `
                        <div class="headline ${isBrief ? 'svo' : ''}" data-full="${article.title || 'No title'}" data-brief="${article.title_distilled || 'No distilled title'}">
                            ${isRead ? (article.title || 'No title') : (article.title_distilled || article.title || 'No distilled title')}
                        </div>
                        <div class="content" data-full="${article.content || article.description || 'No content'}" data-brief="${article.content_distilled || article.description_distilled || 'No distilled content'}">
                            ${isRead ? (article.content || article.description || 'No content') : (article.content_distilled || article.description_distilled || article.content || article.description || 'No distilled content')}
                        </div>
                        <div class="metadata">
                            <div class="source">${article.source || article.source?.name || 'Unknown Source'}</div>
                            <div class="time">${new Date(article.publishedAt).toLocaleDateString()}</div>
                        </div>
                        <div class="progress-bar" style="width: ${((index + 1) / shorts.length) * 100}%"></div>
                    `;
                }
                container.appendChild(shortDiv);
            });
        }

        async function loadGraphForArticle(index, article) {
            // Load and display knowledge graph using Vis.js
            const graphContainer = document.getElementById(`graph-${index}`);
            
            if (!graphContainer) {
                console.error(`Graph container graph-${index} not found`);
                return;
            }
            
            // Make container fill the graph-content area
            graphContainer.style.width = '100%';
            graphContainer.style.height = '100%';
            
            try {
                console.log(`Loading graph for article ${index}:`, article.title);
                
                // Use embedded graph data if available
                if (article.graph && article.graph.entities) {
                    console.log('Using embedded graph data with Vis.js');
                    createVisJsGraph(graphContainer, article.graph);
                } else {
                    console.log('Generating fallback graph');
                    // Fallback to generating basic graph
                    const entities = extractSimpleEntities(`${article.title || ''} ${article.description || article.content || ''}`);
                    const relationships = extractSimpleRelationships(`${article.title || ''} ${article.description || article.content || ''}`, entities);
                    
                    createVisJsGraph(graphContainer, {
                        entities: entities,
                        relationships: relationships
                    });
                }
            } catch (error) {
                console.error('Graph loading failed:', error);
                graphContainer.innerHTML = `<p style="color: white;">Graph loading failed: ${error.message}</p>`;
            }
        }

        function createVisJsGraph(container, graphData) {
            // Clear container
            container.innerHTML = '';
            
            if (!graphData || !graphData.entities || graphData.entities.length === 0) {
                container.innerHTML = '<p style="color: white; text-align: center; padding: 20px;">No entities found</p>';
                return;
            }

            // Create nodes from entities with improved styling
            const nodeCount = graphData.entities.length;
            const useCircular = nodeCount <= 8; // Use circular for small graphs, force-directed for larger
            
            const nodes = new vis.DataSet(
                graphData.entities.map((entity, index) => {
                    let position = {};
                    
                    if (useCircular) {
                        // Circular layout for small graphs
                        const radius = Math.min(150, 50 + nodeCount * 15);
                        const angle = (2 * Math.PI * index) / nodeCount;
                        position = {
                            x: radius * Math.cos(angle),
                            y: radius * Math.sin(angle),
                            fixed: { x: true, y: true }
                        };
                    }
                    
                    return {
                        id: index,
                        label: '', // Rams: No labels - let interaction reveal information
                        group: entity.type,
                        title: `<strong>${entity.type}</strong><br/>${entity.name}<br/>Click to highlight connections`,
                        font: { 
                            color: 'white', 
                            size: 0, // No font needed for empty labels
                        },
                        borderWidth: 3,
                        borderWidthSelected: 5,
                        size: 30,
                        shadow: {
                            enabled: true,
                            color: 'rgba(0,0,0,0.5)',
                            size: 8,
                            x: 2,
                            y: 2
                        },
                        ...position
                    };
                })
            );

            // Create edges from relationships with improved styling
            const edges = new vis.DataSet(
                (graphData.relationships || []).map(rel => {
                    const fromIndex = graphData.entities.findIndex(e => e.name === rel.from);
                    const toIndex = graphData.entities.findIndex(e => e.name === rel.to);
                    
                    if (fromIndex !== -1 && toIndex !== -1) {
                        return {
                            from: fromIndex,
                            to: toIndex,
                            label: rel.type.replace(/_/g, ' '), // Cleaner labels
                            arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                            font: { 
                                color: 'white', 
                                size: 12,
                                strokeWidth: 2,
                                strokeColor: 'black',
                                face: 'Arial'
                            },
                            color: { 
                                color: 'rgba(255,255,255,0.9)',
                                highlight: 'rgba(255,215,0,1)', // Gold highlight
                                hover: 'rgba(255,255,255,1)'
                            },
                            width: 2,
                            smooth: {
                                type: 'curvedCW',
                                roundness: 0.2
                            },
                            shadow: {
                                enabled: true,
                                color: 'rgba(0,0,0,0.3)',
                                size: 5
                            }
                        };
                    }
                    return null;
                }).filter(edge => edge !== null)
            );

            // Network options with enhanced features
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 30,
                    borderWidth: 3,
                    shadow: {
                        enabled: true,
                        color: 'rgba(0,0,0,0.5)',
                        size: 8
                    },
                    chosen: {
                        node: function(values, id, selected, hovering) {
                            values.size = 40; // Slightly larger when selected
                        }
                    }
                },
                edges: {
                    width: 2,
                    color: { 
                        inherit: true,
                        opacity: 0.8
                    },
                    smooth: {
                        type: useCircular ? 'curvedCW' : 'dynamic',
                        roundness: 0.2
                    },
                    arrows: {
                        to: { enabled: true, scaleFactor: 1.2 }
                    },
                    font: {
                        color: 'white',
                        size: 12,
                        strokeWidth: 2,
                        strokeColor: 'black',
                        face: 'Arial'
                    },
                    shadow: {
                        enabled: true,
                        color: 'rgba(0,0,0,0.3)',
                        size: 5
                    }
                },
                groups: {
                    PERSON: { 
                        color: { 
                            background: '#FF6B6B', 
                            border: '#FF4444',
                            highlight: { background: '#FF5555', border: '#FF2222' }
                        } 
                    },
                    ORGANIZATION: { 
                        color: { 
                            background: '#4ECDC4', 
                            border: '#2EAD9A',
                            highlight: { background: '#3EBDB4', border: '#1E9D8A' }
                        } 
                    },
                    LOCATION: { 
                        color: { 
                            background: '#45B7D1', 
                            border: '#2E95B1',
                            highlight: { background: '#35A7C1', border: '#1E85A1' }
                        } 
                    },
                    WORK: { 
                        color: { 
                            background: '#9C27B0', 
                            border: '#7C1B90',
                            highlight: { background: '#8C17A0', border: '#6C0B80' }
                        } 
                    },
                    EVENT: { 
                        color: { 
                            background: '#AB47BC', 
                            border: '#8B279C',
                            highlight: { background: '#9B37AC', border: '#7B178C' }
                        } 
                    },
                    OTHER: { 
                        color: { 
                            background: '#78909C', 
                            border: '#58707C',
                            highlight: { background: '#68808C', border: '#48606C' }
                        } 
                    }
                },
                physics: {
                    enabled: !useCircular,  // Enable physics for force-directed layout
                    stabilization: { iterations: 100 },
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 95,
                        springConstant: 0.04,
                        damping: 0.09,
                        avoidOverlap: 0.1
                    }
                },
                interaction: {
                    hover: true,
                    selectConnectedEdges: true,
                    dragNodes: !useCircular,  // Allow dragging for force-directed
                    zoomView: true,
                    dragView: true,
                    tooltipDelay: 200
                },
                layout: {
                    randomSeed: 42,
                    improvedLayout: !useCircular
                }
            };

            // Create network
            const data = { nodes: nodes, edges: edges };
            const network = new vis.Network(container, data, options);

            // Add interaction handlers
            network.on("click", function(params) {
                // Mark graph as engaged on any click
                markGraphEngaged();
                
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    const entity = graphData.entities[nodeId];
                    const connectedNodes = network.getConnectedNodes(nodeId);
                    const connectedEdges = network.getConnectedEdges(nodeId);
                    
                    // Show entity information (Rams: reveal on interaction)
                    const entityInfo = document.getElementById(`entity-info-${currentShort}`);
                    const entityName = document.getElementById(`entity-name-${currentShort}`);
                    const entityType = document.getElementById(`entity-type-${currentShort}`);
                    
                    if (entityInfo && entityName && entityType && entity) {
                        entityName.textContent = entity.name;
                        entityType.textContent = entity.type;
                        entityInfo.classList.add('visible');
                    }
                    
                    // Highlight connected nodes and edges
                    const updateArray = [];
                    nodes.forEach(function(node) {
                        if (connectedNodes.indexOf(node.id) !== -1 || node.id === nodeId) {
                            updateArray.push({
                                id: node.id,
                                opacity: 1,
                                size: 40
                            });
                        } else {
                            updateArray.push({
                                id: node.id,
                                opacity: 0.3,
                                size: 25
                            });
                        }
                    });
                    
                    nodes.update(updateArray);
                    
                    // Highlight edges
                    const edgeUpdateArray = [];
                    edges.forEach(function(edge) {
                        if (connectedEdges.indexOf(edge.id) !== -1) {
                            edgeUpdateArray.push({
                                id: edge.id,
                                color: { color: '#FFD700', opacity: 1 },
                                width: 4
                            });
                        } else {
                            edgeUpdateArray.push({
                                id: edge.id,
                                color: { color: 'rgba(255,255,255,0.2)', opacity: 0.2 },
                                width: 1
                            });
                        }
                    });
                    
                    edges.update(edgeUpdateArray);
                } else {
                    // Hide entity info on background click
                    const entityInfo = document.getElementById(`entity-info-${currentShort}`);
                    if (entityInfo) {
                        entityInfo.classList.remove('visible');
                    }
                }
            });

            // Reset highlighting on background click
            network.on("click", function(params) {
                if (params.nodes.length === 0) {
                    // Reset all nodes and edges to original state
                    const resetNodes = nodes.map(node => ({
                        id: node.id,
                        opacity: 1,
                        size: 30
                    }));
                    
                    const resetEdges = edges.map(edge => ({
                        id: edge.id,
                        color: { color: 'rgba(255,255,255,0.9)', opacity: 0.8 },
                        width: 2
                    }));
                    
                    nodes.update(resetNodes);
                    edges.update(resetEdges);
                }
            });
            
            // Track additional engagement events
            network.on("zoom", function(params) {
                markGraphEngaged();
            });
            
            network.on("dragStart", function(params) {
                markGraphEngaged();
            });
            
            network.on("dragging", function(params) {
                markGraphEngaged();
            });
            
            network.on("hoverNode", function(params) {
                markGraphEngaged();
            });

            // Fit network to container
            setTimeout(() => {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }, useCircular ? 100 : 1000); // Wait longer for physics stabilization

            return network;
        }

        async function generateInlineGraph(article) {
            // Generate a simple SVG graph for the article
            const text = `${article.title || ''} ${article.description || article.content || ''}`;
            console.log('Generating graph for text:', text.substring(0, 100) + '...');
            
            // Simple entity extraction (basic implementation)
            const entities = extractSimpleEntities(text);
            const relationships = extractSimpleRelationships(text, entities);
            
            console.log('Extracted entities:', entities);
            console.log('Extracted relationships:', relationships);
            
            if (entities.length === 0) {
                return '<p style="color: white;">No entities found</p>';
            }
            
            // Generate simple SVG
            return generateSimpleSVG(entities, relationships);
        }

        function extractSimpleEntities(text) {
            // Extract entities using simple pattern matching
            const entities = [];
            
            if (!text || text.trim().length === 0) {
                return entities;
            }
            
            // Extract proper nouns (capitalized words)
            const words = text.split(/\s+/);
            const properNouns = words.filter(word => {
                // Remove punctuation and check if starts with capital
                const cleanWord = word.replace(/[^\w]/g, '');
                return cleanWord.length > 2 && /^[A-Z][a-z]+/.test(cleanWord);
            });
            
            // Categorize entities
            const locations = ['Scranton', 'Pennsylvania', 'County', 'City', 'Hall', 'Theater', 'Lake', 'Street', 'Avenue', 'Road'];
            const organizations = ['Police', 'Department', 'Office', 'Service', 'Company', 'Association', 'School', 'University', 'Hospital'];
            
            properNouns.forEach(word => {
                const cleanWord = word.replace(/[^\w]/g, '');
                let type = 'Person';
                
                if (locations.some(loc => cleanWord.includes(loc) || loc.includes(cleanWord))) {
                    type = 'Location';
                } else if (organizations.some(org => cleanWord.includes(org) || org.includes(cleanWord))) {
                    type = 'Organization';
                }
                
                if (!entities.find(e => e.name === cleanWord) && cleanWord.length > 2) {
                    entities.push({ name: cleanWord, type: type });
                }
            });
            
            // Add some default entities if none found
            if (entities.length === 0) {
                entities.push(
                    { name: 'Scranton', type: 'Location' },
                    { name: 'News', type: 'Organization' },
                    { name: 'Community', type: 'Organization' }
                );
            }
            
            return entities.slice(0, 6); // Limit to 6 entities for readability
        }

        function extractSimpleRelationships(text, entities) {
            // Extract simple relationships between entities
            const relationships = [];
            const lowerText = text.toLowerCase();
            
            // Simple relationship patterns
            const patterns = [
                { pattern: /(\w+)\s+(?:joined|joins)\s+(\w+)/, type: 'JOINED' },
                { pattern: /(\w+)\s+(?:at|in)\s+(\w+)/, type: 'LOCATED_AT' },
                { pattern: /(\w+)\s+(?:announced|said)/, type: 'ANNOUNCED' }
            ];
            
            patterns.forEach(({ pattern, type }) => {
                const matches = lowerText.match(pattern);
                if (matches && matches.length > 2) {
                    const subject = entities.find(e => e.name.toLowerCase() === matches[1]);
                    const object = entities.find(e => e.name.toLowerCase() === matches[2]);
                    
                    if (subject && object) {
                        relationships.push({ from: subject.name, to: object.name, type: type });
                    }
                }
            });
            
            return relationships;
        }

        function generateSimpleSVG(entities, relationships) {
            // Generate a simple SVG representation of the graph
            const colors = {
                'Person': '#FF6B6B',
                'Organization': '#4ECDC4', 
                'Location': '#45B7D1'
            };
            
            let svg = '<svg width="300" height="200" viewBox="0 0 300 200" class="graph-svg">';
            
            // Draw entities as circles
            entities.forEach((entity, i) => {
                const x = 50 + (i % 3) * 100;
                const y = 50 + Math.floor(i / 3) * 60;
                const color = colors[entity.type] || '#888';
                
                svg += `<circle cx="${x}" cy="${y}" r="20" fill="${color}" stroke="white" stroke-width="2"/>`;
                svg += `<text x="${x}" y="${y-25}" text-anchor="middle" fill="white" font-size="10" font-weight="bold">${entity.name}</text>`;
                svg += `<text x="${x}" y="${y+35}" text-anchor="middle" fill="white" font-size="8">${entity.type}</text>`;
            });
            
            // Draw relationships as lines
            relationships.forEach(rel => {
                const fromEntity = entities.find(e => e.name === rel.from);
                const toEntity = entities.find(e => e.name === rel.to);
                
                if (fromEntity && toEntity) {
                    const fromIndex = entities.indexOf(fromEntity);
                    const toIndex = entities.indexOf(toEntity);
                    
                    const x1 = 50 + (fromIndex % 3) * 100;
                    const y1 = 50 + Math.floor(fromIndex / 3) * 60;
                    const x2 = 50 + (toIndex % 3) * 100;
                    const y2 = 50 + Math.floor(toIndex / 3) * 60;
                    
                    svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="white" stroke-width="1" opacity="0.7"/>`;
                    
                    // Add relationship label
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    svg += `<text x="${midX}" y="${midY}" text-anchor="middle" fill="white" font-size="8">${rel.type}</text>`;
                }
            });
            
            svg += '</svg>';
            return svg;
        }

        function setMode(mode) {
            currentMode = mode;
            
            // Update button states - pure Rams: one active state, clear purpose
            document.getElementById('readBtn').classList.toggle('active', mode === 'read');
            document.getElementById('briefBtn').classList.toggle('active', mode === 'brief');
            document.getElementById('exploreBtn').classList.toggle('active', mode === 'explore');
            
            // Recreate shorts with new mode
            createShorts();
            showShort(currentShort);
        }

        // Legacy functions for backward compatibility
        function setView(view) {
            setMode(view === 'graph' ? 'explore' : 'read');
        }

        function setFormat(format) {
            setMode(format === 'brief' ? 'brief' : 'read');
        }

        function toggleView() {
            setMode(currentMode === 'explore' ? 'read' : 'explore');
        }

        function toggleFormat() {
            setMode(currentMode === 'read' ? 'brief' : 'read');
        }

        function showShort(index) {
            const shortElements = document.querySelectorAll('.short');
            
            shortElements.forEach((short, i) => {
                short.classList.remove('active', 'prev', 'next');
                
                if (i === index) {
                    short.classList.add('active');
                } else if (i < index) {
                    short.classList.add('prev');
                } else {
                    short.classList.add('next');
                }
            });

            currentShort = index;
            
            // Clear any existing timer
            if (autoAdvanceTimer) {
                clearTimeout(autoAdvanceTimer);
                autoAdvanceTimer = null;
            }
            
            // Reset graph engagement when switching shorts
            graphEngaged = false;
            
            // Set auto-advance timer (10 seconds for text modes, 15 seconds for explore)
            const delay = currentMode === 'explore' ? 15000 : 10000;
            autoAdvanceTimer = setTimeout(() => {
                // Only advance if still on same short AND graph is not engaged
                if (currentShort === index && !graphEngaged) {
                    nextShort();
                }
            }, delay);
        }

        function nextShort() {
            const nextIndex = (currentShort + 1) % shorts.length;
            showShort(nextIndex);
        }

        function previousShort() {
            const prevIndex = currentShort === 0 ? shorts.length - 1 : currentShort - 1;
            showShort(prevIndex);
        }

        function toggleFormat() {
            showSVO = !showSVO;
            const toggleBtn = document.getElementById('formatToggle');
            toggleBtn.textContent = showSVO ? 'Distilled' : 'Original';
            
            // Update all visible text
            document.querySelectorAll('.headline').forEach(headline => {
                headline.textContent = showSVO ? headline.dataset.svo : headline.dataset.original;
                headline.classList.toggle('svo', showSVO);
            });
            
            document.querySelectorAll('.content').forEach(content => {
                content.textContent = showSVO ? content.dataset.svo : content.dataset.original;
            });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    previousShort();
                    break;
                case 'ArrowDown':
                case ' ':
                    e.preventDefault();
                    nextShort();
                    break;
                case 'f':
                case 'b':
                    setMode(currentMode === 'brief' ? 'read' : 'brief');
                    break;
                case 'g':
                case 'e':
                    setMode(currentMode === 'explore' ? 'read' : 'explore');
                    break;
            }
        });

        // Touch/swipe support
        let startY = 0;
        let startX = 0;

        document.addEventListener('touchstart', (e) => {
            startY = e.touches[0].clientY;
            startX = e.touches[0].clientX;
        });

        document.addEventListener('touchend', (e) => {
            const endY = e.changedTouches[0].clientY;
            const endX = e.changedTouches[0].clientX;
            const diffY = startY - endY;
            const diffX = startX - endX;
            
            // Vertical swipe (primary navigation)
            if (Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 50) {
                if (diffY > 0) {
                    nextShort(); // Swipe up = next
                } else {
                    previousShort(); // Swipe down = previous
                }
            }
            // Horizontal swipe for mode toggle
            else if (Math.abs(diffX) > 100) {
                setMode(currentMode === 'brief' ? 'read' : 'brief');
            }
        });

        // Initialize with error handling
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Scrantenna Shorts starting...');
            loadNews().catch(error => {
                console.error('Failed to load news:', error);
                document.getElementById('shortsContainer').innerHTML = 
                    '<div class="short active" style="background: #333; display: flex; align-items: center; justify-content: center;"><h2>Loading failed. Check console for details.</h2></div>';
            });
        });
    </script>
</body>
</html>